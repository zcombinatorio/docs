---
title: "Redeem"
description: "Convert winning conditional tokens back to regular tokens after resolution"
---

## Overview

Redeem winning conditional tokens back to regular tokens after a proposal has resolved. Only the winning conditional tokens can be redeemed—losing tokens become worthless.

| Winning Outcome | Redeemable Token | Value |
|-----------------|------------------|-------|
| Pass | Pass tokens | 1:1 for regular |
| Fail | Fail tokens | 1:1 for regular |

This is a two-step process:
1. **Build** - Request an unsigned transaction from the API
2. **Execute** - Sign the transaction and submit it back

<Info>
Redemption is only available **after** a proposal has resolved. Use the [market-status endpoint](/api-reference/trading/market-status) to check if a proposal is resolved.
</Info>

---

## Build Transaction

`POST /dao/proposal/:proposalPda/redeem/build`

Builds an unsigned redemption transaction for the user to sign.

<CodeGroup>
```bash curl
curl -X POST https://api.zcombinator.io/dao/proposal/ABC123.../redeem/build \
  -H "Content-Type: application/json" \
  -d '{
    "wallet": "UserWallet123...",
    "vaultType": "base"
  }'
```
```javascript fetch
const response = await fetch(
  'https://api.zcombinator.io/dao/proposal/ABC123.../redeem/build',
  {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      wallet: 'UserWallet123...',
      vaultType: 'base'
    })
  }
);
const { requestId, transaction, winningIndex } = await response.json();
```
```python requests
import requests

response = requests.post(
    'https://api.zcombinator.io/dao/proposal/ABC123.../redeem/build',
    json={
        'wallet': 'UserWallet123...',
        'vaultType': 'base'
    }
)
data = response.json()
```
</CodeGroup>

### Path Parameters

<ParamField path="proposalPda" type="string" required>
  The Solana PDA of the proposal
</ParamField>

### Request Body

<ParamField body="wallet" type="string" required>
  The user's Solana wallet address
</ParamField>

<ParamField body="vaultType" type="string" required>
  Which vault to redeem from: `base` or `quote`
</ParamField>

### Build Response

<ResponseField name="requestId" type="string">
  Unique identifier for this request
</ResponseField>

<ResponseField name="transaction" type="string">
  Base58-encoded unsigned transaction
</ResponseField>

<ResponseField name="expiresAt" type="number">
  Unix timestamp (ms) when this request expires
</ResponseField>

<ResponseField name="vaultPda" type="string">
  The vault's Solana PDA
</ResponseField>

<ResponseField name="vaultType" type="string">
  The vault type used
</ResponseField>

<ResponseField name="winningIndex" type="number">
  The index of the winning outcome (0 = pass, 1 = fail)
</ResponseField>

```json
{
  "requestId": "a1b2c3d4e5f6...",
  "transaction": "4vJ9JU1bJJE96FwQGq...",
  "expiresAt": 1704153600000,
  "vaultPda": "Vault789...",
  "vaultType": "base",
  "winningIndex": 0
}
```

---

## Execute Transaction

`POST /dao/proposal/:proposalPda/redeem/execute`

Executes a signed redemption transaction that was previously built.

<CodeGroup>
```bash curl
curl -X POST https://api.zcombinator.io/dao/proposal/ABC123.../redeem/execute \
  -H "Content-Type: application/json" \
  -d '{
    "requestId": "a1b2c3d4e5f6...",
    "signedTransaction": "4vJ9JU1bJJE96FwQGq..."
  }'
```
```javascript fetch
const response = await fetch(
  'https://api.zcombinator.io/dao/proposal/ABC123.../redeem/execute',
  {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      requestId: 'a1b2c3d4e5f6...',
      signedTransaction: bs58.encode(signedTx.serialize())
    })
  }
);
const { success, signature } = await response.json();
```
```python requests
import requests

response = requests.post(
    'https://api.zcombinator.io/dao/proposal/ABC123.../redeem/execute',
    json={
        'requestId': 'a1b2c3d4e5f6...',
        'signedTransaction': '<base58-encoded-signed-transaction>'
    }
)
data = response.json()
```
</CodeGroup>

### Request Body

<ParamField body="requestId" type="string" required>
  The request ID returned from the build endpoint
</ParamField>

<ParamField body="signedTransaction" type="string" required>
  Base58-encoded transaction with user's signature
</ParamField>

### Execute Response

<ResponseField name="success" type="boolean">
  Whether the transaction was successfully submitted and confirmed
</ResponseField>

<ResponseField name="signature" type="string">
  The Solana transaction signature
</ResponseField>

<ResponseField name="proposalPda" type="string">
  The proposal PDA
</ResponseField>

<ResponseField name="vaultPda" type="string">
  The vault PDA
</ResponseField>

<ResponseField name="vaultType" type="string">
  The vault type (`base` or `quote`)
</ResponseField>

```json
{
  "success": true,
  "signature": "5K8M3H...",
  "proposalPda": "ABC123...",
  "vaultPda": "Vault789...",
  "vaultType": "base"
}
```

---

## Error Responses

<AccordionGroup>
  <Accordion title="400 - Invalid vault type">
    ```json
    { "error": "Invalid vaultType. Must be \"base\" or \"quote\"" }
    ```
  </Accordion>
  <Accordion title="400 - Proposal not resolved">
    ```json
    {
      "error": "Proposal is not resolved",
      "state": "pending",
      "message": "Redemptions are only available after proposal is resolved"
    }
    ```
  </Accordion>
  <Accordion title="400 - Request not found or expired">
    ```json
    { "error": "Request not found or expired" }
    ```
  </Accordion>
  <Accordion title="400 - Transaction modified">
    ```json
    { "error": "Transaction verification failed: transaction has been modified" }
    ```
  </Accordion>
  <Accordion title="400 - Blockhash expired">
    ```json
    { "error": "Invalid transaction: blockhash is expired. Please create a new transaction." }
    ```
  </Accordion>
  <Accordion title="404 - Proposal not found">
    ```json
    {
      "error": "Proposal not found on-chain",
      "details": "Account not found..."
    }
    ```
  </Accordion>
</AccordionGroup>

---

## Complete Example

```javascript
import { Transaction } from '@solana/web3.js';
import bs58 from 'bs58';

async function redeemWinnings(proposalPda, wallet, vaultType, signTransaction) {
  // 1. Build the redeem transaction
  const buildRes = await fetch(
    `${API_URL}/dao/proposal/${proposalPda}/redeem/build`,
    {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ wallet, vaultType })
    }
  );
  const { requestId, transaction, winningIndex } = await buildRes.json();

  console.log(`Redeeming tokens. Winning outcome: ${winningIndex === 0 ? 'Pass' : 'Fail'}`);

  // 2. Decode and sign
  const tx = Transaction.from(bs58.decode(transaction));
  const signedTx = await signTransaction(tx);

  // 3. Execute
  const execRes = await fetch(
    `${API_URL}/dao/proposal/${proposalPda}/redeem/execute`,
    {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        requestId,
        signedTransaction: bs58.encode(signedTx.serialize())
      })
    }
  );

  return execRes.json();
}
```

---

## Example Scenarios

**Scenario 1: You held pass tokens, proposal passed**
```
Before: 100 pass-ZC, 0 fail-ZC
Redeem: 100 pass-ZC → 100 ZC
After: 100 ZC
```

**Scenario 2: You held pass tokens, proposal failed**
```
Before: 100 pass-ZC, 0 fail-ZC
Result: Pass tokens are worthless
After: 0 ZC (loss)
```

**Scenario 3: You held equal positions (hedged)**
```
Before: 50 pass-ZC, 50 fail-ZC
Proposal passes: Redeem 50 pass-ZC → 50 ZC
Lose: 50 fail-ZC (worthless)
After: 50 ZC
```

---

## Full Trading Lifecycle

```javascript
async function futarchyTradingExample() {
  const proposalPda = 'ABC123...';
  const wallet = publicKey.toString();

  // 1. Check market status
  const status = await fetch(`${API_URL}/dao/proposal/${proposalPda}/market-status`);
  const { state, leadingOption } = await status.json();

  if (state === 'pending') {
    // 2. Deposit tokens to get conditional tokens
    await depositTokens(proposalPda, wallet, 'base', '100000000000');

    // 3. Swap to take a position (e.g., go long on pass)
    await swapTokens(proposalPda, wallet, 0, true, '50000000000');

    // Wait for proposal to resolve...
  } else if (state === 'resolved') {
    // 4. Redeem winning tokens
    await redeemWinnings(proposalPda, wallet, 'base');

    // 5. Check final balance
    const balances = await fetch(`${API_URL}/dao/proposal/${proposalPda}/balances/${wallet}`);
    console.log('Final balances:', await balances.json());
  }
}
```

---

## Notes

- Only winning conditional tokens can be redeemed
- Losing tokens are automatically burned during redemption
- Redemption is available indefinitely after resolution—no deadline
- Redeem from both `base` and `quote` vaults if you have positions in both
- The regular token ATA is created automatically if needed
