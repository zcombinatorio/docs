---
title: "Withdraw"
description: "Merge conditional tokens back into regular tokens"
---

## Overview

Withdraw (merge) conditional tokens back into regular tokens. This is useful for exiting a position without taking directional risk.

```
1 pass token + 1 fail token â†’ 1 regular token
```

You must have **equal amounts** of both pass and fail tokens to withdraw. This is the inverse of depositing.

This is a two-step process:
1. **Build** - Request an unsigned transaction from the API
2. **Execute** - Sign the transaction and submit it back

---

## Build Transaction

`POST /dao/proposal/:proposalPda/withdraw/build`

Builds an unsigned withdraw transaction for the user to sign.

<CodeGroup>
```bash curl
curl -X POST https://api.zcombinator.io/dao/proposal/ABC123.../withdraw/build \
  -H "Content-Type: application/json" \
  -d '{
    "wallet": "UserWallet123...",
    "vaultType": "base",
    "amount": "1000000000"
  }'
```
```javascript fetch
const response = await fetch(
  'https://api.zcombinator.io/dao/proposal/ABC123.../withdraw/build',
  {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      wallet: 'UserWallet123...',
      vaultType: 'base',
      amount: '1000000000'
    })
  }
);
const { requestId, transaction } = await response.json();
```
```python requests
import requests

response = requests.post(
    'https://api.zcombinator.io/dao/proposal/ABC123.../withdraw/build',
    json={
        'wallet': 'UserWallet123...',
        'vaultType': 'base',
        'amount': '1000000000'
    }
)
data = response.json()
```
</CodeGroup>

### Path Parameters

<ParamField path="proposalPda" type="string" required>
  The Solana PDA of the proposal
</ParamField>

### Request Body

<ParamField body="wallet" type="string" required>
  The user's Solana wallet address
</ParamField>

<ParamField body="vaultType" type="string" required>
  Which vault to withdraw from: `base` or `quote`
</ParamField>

<ParamField body="amount" type="string" required>
  Amount to withdraw in raw token units
</ParamField>

### Build Response

<ResponseField name="requestId" type="string">
  Unique identifier for this request
</ResponseField>

<ResponseField name="transaction" type="string">
  Base58-encoded unsigned transaction
</ResponseField>

<ResponseField name="expiresAt" type="number">
  Unix timestamp (ms) when this request expires
</ResponseField>

<ResponseField name="vaultPda" type="string">
  The vault's Solana PDA
</ResponseField>

<ResponseField name="vaultType" type="string">
  The vault type used
</ResponseField>

<ResponseField name="amount" type="string">
  The withdrawal amount
</ResponseField>

```json
{
  "requestId": "a1b2c3d4e5f6...",
  "transaction": "4vJ9JU1bJJE96FwQGq...",
  "expiresAt": 1704153600000,
  "vaultPda": "Vault789...",
  "vaultType": "base",
  "amount": "1000000000"
}
```

---

## Execute Transaction

`POST /dao/proposal/:proposalPda/withdraw/execute`

Executes a signed withdraw transaction that was previously built.

<CodeGroup>
```bash curl
curl -X POST https://api.zcombinator.io/dao/proposal/ABC123.../withdraw/execute \
  -H "Content-Type: application/json" \
  -d '{
    "requestId": "a1b2c3d4e5f6...",
    "signedTransaction": "4vJ9JU1bJJE96FwQGq..."
  }'
```
```javascript fetch
const response = await fetch(
  'https://api.zcombinator.io/dao/proposal/ABC123.../withdraw/execute',
  {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      requestId: 'a1b2c3d4e5f6...',
      signedTransaction: bs58.encode(signedTx.serialize())
    })
  }
);
const { success, signature } = await response.json();
```
```python requests
import requests

response = requests.post(
    'https://api.zcombinator.io/dao/proposal/ABC123.../withdraw/execute',
    json={
        'requestId': 'a1b2c3d4e5f6...',
        'signedTransaction': '<base58-encoded-signed-transaction>'
    }
)
data = response.json()
```
</CodeGroup>

### Request Body

<ParamField body="requestId" type="string" required>
  The request ID returned from the build endpoint
</ParamField>

<ParamField body="signedTransaction" type="string" required>
  Base58-encoded transaction with user's signature
</ParamField>

### Execute Response

<ResponseField name="success" type="boolean">
  Whether the transaction was successfully submitted and confirmed
</ResponseField>

<ResponseField name="signature" type="string">
  The Solana transaction signature
</ResponseField>

<ResponseField name="proposalPda" type="string">
  The proposal PDA
</ResponseField>

<ResponseField name="vaultPda" type="string">
  The vault PDA
</ResponseField>

<ResponseField name="vaultType" type="string">
  The vault type (`base` or `quote`)
</ResponseField>

```json
{
  "success": true,
  "signature": "5K8M3H...",
  "proposalPda": "ABC123...",
  "vaultPda": "Vault789...",
  "vaultType": "base"
}
```

---

## Error Responses

<AccordionGroup>
  <Accordion title="400 - Invalid vault type">
    ```json
    { "error": "Invalid vaultType. Must be \"base\" or \"quote\"" }
    ```
  </Accordion>
  <Accordion title="400 - Proposal not active">
    ```json
    {
      "error": "Proposal is not active",
      "state": "resolved",
      "message": "Withdrawals are only available when proposal is in pending state"
    }
    ```
  </Accordion>
  <Accordion title="400 - Request not found or expired">
    ```json
    { "error": "Request not found or expired" }
    ```
  </Accordion>
  <Accordion title="400 - Transaction modified">
    ```json
    { "error": "Transaction verification failed: transaction has been modified" }
    ```
  </Accordion>
  <Accordion title="400 - Blockhash expired">
    ```json
    { "error": "Invalid transaction: blockhash is expired. Please create a new transaction." }
    ```
  </Accordion>
  <Accordion title="404 - Proposal not found">
    ```json
    {
      "error": "Proposal not found on-chain",
      "details": "Account not found..."
    }
    ```
  </Accordion>
</AccordionGroup>

---

## Complete Example

```javascript
import { Transaction } from '@solana/web3.js';
import bs58 from 'bs58';

async function withdrawTokens(proposalPda, wallet, vaultType, amount, signTransaction) {
  // 1. Build the withdraw transaction
  const buildRes = await fetch(
    `${API_URL}/dao/proposal/${proposalPda}/withdraw/build`,
    {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ wallet, vaultType, amount })
    }
  );
  const { requestId, transaction } = await buildRes.json();

  // 2. Decode and sign
  const tx = Transaction.from(bs58.decode(transaction));
  const signedTx = await signTransaction(tx);

  // 3. Execute
  const execRes = await fetch(
    `${API_URL}/dao/proposal/${proposalPda}/withdraw/execute`,
    {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        requestId,
        signedTransaction: bs58.encode(signedTx.serialize())
      })
    }
  );

  return execRes.json();
}
```

---

## When to Withdraw

- **Exit without position** - If you have equal pass and fail tokens, merge them back
- **Rebalance** - Partial withdrawal to reduce exposure
- **Before resolution** - Convert back to regular tokens if outcome is uncertain

---

## Cannot Withdraw If Unbalanced

You **cannot withdraw** if you have an unequal position:

```json
// This position CANNOT be withdrawn directly:
{
  "conditionalBalances": ["150000000", "50000000"]  // 150 pass, 50 fail
}

// First swap 50 pass for fail to equalize
// Then you can withdraw 100 (50 pass + 50 fail)
```

---

## Notes

- The regular token ATA is created automatically if needed
- Amount must not exceed your minimum conditional token balance
- Withdraw is only available during the pending (active trading) state
- After withdrawal, equal amounts of pass and fail tokens are burned
